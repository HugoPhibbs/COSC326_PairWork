Index: src/counting_it_up/CountingItUp.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package counting_it_up;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Scanner;\r\n\r\nimport static java.lang.Long.parseLong;\r\nimport static java.lang.Integer.parseInt;\r\n\r\n/**\r\n * Class that does the \"Counting it up\" program\r\n */\r\npublic class CountingItUp {\r\n\r\n    public static void main(String[] args) {\r\n        new CountingItUp().start();\r\n    }\r\n\r\n    /**\r\n     * Starts the Counting it up Program\r\n     */\r\n    public void start() {\r\n        printCombinations(getInput());\r\n    }\r\n\r\n    /**\r\n     * Finds combinations for lines of input from a user\r\n     *\r\n     * @param lines ArrayList containing Strings for input from a user\r\n     */\r\n    private void printCombinations(ArrayList<String> lines) {\r\n        PositiveBigInt[] nkArray;\r\n        for (String line : lines) {\r\n            try {\r\n                nkArray = parseLine(line);\r\n                System.out.println(combinations(nkArray[0], nkArray[1]));\r\n            } catch (IllegalArgumentException iae) {\r\n                System.out.printf(\"INVALID '%s': %s%n\", line, iae.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a line of input from a user, split into an array for n and k\r\n     *\r\n     * @param line String for input from a user\r\n     * @return PositiveBigInt array, first element is n, and the second is k\r\n     * @throws IllegalArgumentException if the inputted line is invalid\r\n     */\r\n    private PositiveBigInt[] parseLine(String line) throws IllegalArgumentException {\r\n        String[] splitLine = line.split(\" \");\r\n        if (splitLine.length == 2) {\r\n            for (String el : splitLine) {\r\n                if (!PositiveBigInt.stringIsPositiveInt(el)) {\r\n                    throw new IllegalArgumentException(\"Values in inputted line must be positive integers!\");\r\n                }\r\n            }\r\n            PositiveBigInt n = new PositiveBigInt(splitLine[0]);\r\n            PositiveBigInt k = new PositiveBigInt(splitLine[1]);\r\n            return new PositiveBigInt[]{n, k};\r\n        }\r\n        throw new IllegalArgumentException(\"Line must have 2 parts, one for n, one for k\");\r\n    }\r\n\r\n    /**\r\n     * Gets input of and k from a user\r\n     *\r\n     * @return ArrayList for lines of input from a user\r\n     */\r\n    private ArrayList<String> getInput() {\r\n        System.out.println(\"\"\"\r\n                Welcome to counting it up\r\n                Please enter your values of n and k to compute the number of combinations, one per line\r\n                (in the format \"n k\")\r\n                Click enter on an empty line to submit\"\"\");\r\n        Scanner scanner = new Scanner(System.in);\r\n        ArrayList<String> lines = new ArrayList<>();\r\n        String line = scanner.nextLine();\r\n        while (!line.equals(\"\")) {\r\n            lines.add(line);\r\n            line = scanner.nextLine();\r\n        }\r\n        return lines;\r\n    }\r\n\r\n    /**\r\n     * Finds the number of combinations of a given n and k. I.e. finds nCr.\r\n     * <p>\r\n     * Finds a max number of combinations up to 64 bits. In practice this is 66C33 = 7219428434016265740 which is just\r\n     * bellow the threshold of 2^63-1\r\n     *\r\n     * @param n PositiveBigInt\r\n     * @param k PositiveBigInt\r\n     * @return long for combinations as described\r\n     */\r\n    public long combinations(PositiveBigInt n, PositiveBigInt k) {\r\n        if (n.isSmallerThan(k)) {\r\n            return parseLong(nthPascalsRow(k.add(new PositiveBigInt(\"1\"))).get(parseInt(n.getValue())).getValue());\r\n        } else if (k.equals(new PositiveBigInt(\"0\"))) {\r\n            return 1;\r\n        } else {\r\n            return parseLong(nthPascalsRow(n.add(new PositiveBigInt(\"1\"))).get(parseInt(k.getValue())).getValue());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Finds the nth row of Pascals triangle\r\n     *\r\n     * @param n PositiveBigInt for nth row\r\n     * @return ArrayList containing Longs for the nth row\r\n     */\r\n    private ArrayList<PositiveBigInt> nthPascalsRow(PositiveBigInt n) {\r\n        ArrayList<PositiveBigInt> prevRow = new ArrayList<>(List.of(new PositiveBigInt(\"1\")));\r\n        PositiveBigInt i = new PositiveBigInt(\"1\");\r\n        while (i.isSmallerThan(n)) {\r\n            prevRow = createNextRow(prevRow);\r\n            i.increment();\r\n        }\r\n        return prevRow;\r\n    }\r\n\r\n    /**\r\n     * Creates the next row of pascals triangle given an inputted previous row\r\n     *\r\n     * @param prevRow List of PositiveBigInt values for the previous row of pascals triangle\r\n     * @return List containing Longs as described\r\n     */\r\n    private static ArrayList<PositiveBigInt> createNextRow(ArrayList<PositiveBigInt> prevRow) {\r\n        ArrayList<PositiveBigInt> currRow = new ArrayList<>(prevRow.size() + 1);\r\n        currRow.add(new PositiveBigInt(\"1\"));\r\n        for (int i = 1; i < prevRow.size(); i++) {\r\n            currRow.add(prevRow.get(i - 1).add(prevRow.get(i)));\r\n        }\r\n        currRow.add(new PositiveBigInt(\"1\"));\r\n        return currRow;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/counting_it_up/CountingItUp.java b/src/counting_it_up/CountingItUp.java
--- a/src/counting_it_up/CountingItUp.java	(revision b95cc2e999b7d200a425a49834e04137e51f7c24)
+++ b/src/counting_it_up/CountingItUp.java	(date 1652048433429)
@@ -95,7 +95,7 @@
      */
     public long combinations(PositiveBigInt n, PositiveBigInt k) {
         if (n.isSmallerThan(k)) {
-            return parseLong(nthPascalsRow(k.add(new PositiveBigInt("1"))).get(parseInt(n.getValue())).getValue());
+            return 0;
         } else if (k.equals(new PositiveBigInt("0"))) {
             return 1;
         } else {
